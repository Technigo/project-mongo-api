import express from "express";
import cors from "cors";
import mongoose from "mongoose";
import anime from "./data/anime.json"

const mongoUrl = process.env.MONGO_URL || "mongodb://localhost/anime";
mongoose.connect(mongoUrl, { useNewUrlParser: true, useUnifiedTopology: true });
mongoose.Promise = Promise;

const Anime = mongoose.model("Anime",
{
  id: Number,
  title: String,
  synonyms: String,
  japanese: String,
  english: String,
  synopsis: String,
  type: String,
  episodes: Number,
  status: String,
  start_Aired: String,
  end_Aired: String,
  premiered: String,
  broadcast: String,
  producers: String,
  licensors: String,
  studios: String,
  source: String,
  genres: String,
  themes: String,
  demographics: String,
  duration_Minutes: Number,
  rating: String,
  score: Number,
  scored_Users: Number,
  ranked: Number,
  popularity: Number,
  members: Number,
  favorites: Number
}
)

if(process.env.RESET_DB){
  const resetDataBase = async () => {
    await Anime.deleteMany();
    anime.forEach(singleAnime => {
      const newAnime = new Anime(singleAnime);
      newAnime.save()
    })
  }
  resetDataBase();
}

const port = process.env.PORT || 8080;
const app = express();

// Add middlewares to enable cors and json body parsing
app.use(cors());
app.use(express.json());

// Start defining your routes here
app.get("/", (req, res) => {
  res.send([
    {"/": "Anime Playground"},
    {"/animes": "Display all animes"},
    {"/animes/title/:english": "One anime title displayed for other countries than Japan"},
    {"/animes/highscore": "Sorting anime by popularity"},
    {"/animes/type/:type": "Find anime with specific type"},
    {"/animes/status?query={status}": "Find anime with specific status"},
    {"/animes/studios/:studio?premiered={premiered}": "Find anime with specific studio producer and then can filter more depending on when it is premiered"}
  ]);
});

// Display all animes but only return some data such as the title, japanese title, synopsis, score, type, studio, and status. Also it is sorted from the highest score
app.get("/animes", async (req, res) => {
  const animes = await Anime.find({}).sort({score: -1}).select({title: 1, japanese: 1, synopsis: 1, score: 1, type: 1, studios: 1, status: 1})
  res.json(animes)
})

// Display one anime by id number that is generated in Postman
// example /animes/id/{id generated by Postman}
app.get("/animes/id/:id", async (req, res) => {
  try {
    const singleAnime = await Anime.findById(req.params.id);
    if (singleAnime) {
      res.status(200).json({
        success: true,
        body: singleAnime
      });
    } else {
      res.status(404).json({
        success: false,
        body: {
          message: "ID not found"
        }
      });
    }
  } catch(error) {
    res.status(400).json({
      success: false,
      body: {
        message: "Invalid ID"
      }
    });
  } 
});

// Display one anime by the japanese title
// example /animes/japanesetitle/銀魂
app.get("/animes/japanesetitle/:japanese", async (req, res) => {
  try{
    const japaneseTitleRegex = new RegExp(req.params.japanese, "i");
    const animeJapaneseTitle = await Anime.findOne({ japanese: japaneseTitleRegex })

  if(animeJapaneseTitle){
    res.status(200).json({
      data: animeJapaneseTitle,
      success: true,
    })
} else {
    res.status(404).send({
      data: "Title not found",
      success: false 
    }
    )}
} catch(error){
  res.status(400).json({
    success: false,
    body: {
      message: "bad request"
  }})
}})

// Display one anime by the title for worldwide release
// example /animes/title/naruto%20shippuuden
app.get("/animes/title/:english", async (req, res) => {
  try{
    const titleRegex = new RegExp(req.params.english, "i");
    const animeTitle = await Anime.findOne({ english: titleRegex })

  if(animeTitle){
    res.status(200).json({
      data: animeTitle,
      success: true,
    })
} else {
    res.status(404).send({
      data: "Title not found",
      success: false 
    }
    )}
} catch(error){
  res.status(400).json({
    success: false,
    body: {
      message: "bad request"
  }})
}})

// Display all animes that scores 8 or higher
// example /animes/highscore
app.get("/animes/highscore", async (req, res) => {
  try{
    const animeScore = await Anime.find({score: { $gte: 8 }})

    res.status(200).json({
      data: animeScore,
      success: true,
  })
  } catch(error){
    res.status(400).json({
      success: false,
      body: {
        message: "bad request"
    }})
  }
})

// Display all animes based on its type
// example /animes/type/movie
app.get("/animes/type/:type", async (req, res) => {
 try{
  const typeRegex = new RegExp(req.params.type, "i");
  const animeType = await Anime.find({ type: typeRegex })

  if(animeType){
    res.status(200).json({
      data: animeType,
      success: true,
  })
} else{
    res.status(404).json({
      success: false,
      body: {
        message: "Type not found"
      }
    })
  } 
} catch(error){
  res.status(400).json({
    success: false,
    body: {
      message: "bad request"
  }})
} 
})

// Display aall anime with the same airing status
// example /animes/status?query=currently%20airing
app.get("/animes/status", async(req, res) => {
  const { query } = req.query;
  const queryRegex = new RegExp(query, 'i')
  const status = await Anime.find({ status: queryRegex }).select({english: 1, japanese: 1, title: 1, start_Aired: 1, end_Aired: 1, premiered: 1, episodes: 1})
  if(status){
    res.json({
      data: status,
      success: true,
  })
} else {
    res.status(404).json({
      success: false,
      body: {
        message: "No Status"
    }})
  }
})

// Display all animes that are made by the same studio and later on can be filtered more by the time it's premiered.
// So, the example below means: animes that were made by White Fox studio & premiered in Spring 2016 (but even if the premiered time is omitted it should still work fine)
// example /animes/studios/madhouse?premiered=fall%202015
app.get("/animes/studios/:studios", async (req, res) => {
  const studioRegex = new RegExp(req.params.studios, "i");
  const premieredRegex = new RegExp(req.query.premiered, "i")
  const animeStudio = await Anime.find({ 
    studios: studioRegex,
    premiered: premieredRegex
})
  if(animeStudio){
    res.json({
      data: animeStudio,
      success: true,
    })
} else {
    res.status(404).json({
      success: false,
      body: {
        message: "Studio not found"
      }})
    }
})

// Start the server
app.listen(port, () => {
  console.log(`Server running on http://localhost:${port}`);
});
